import Mathlib.Tactic

/- TEXT:
.. _inductively_defined_types:

Inductively Defined Types
-------------------------

Lean's foundation allows us to define inductive types, that is, data types whose instances
are generated from the bottom up.
For example, the data type ``List α`` of lists of elements of ``α`` is generated by starting
with the empty list, ``nil``, and successively adding elements to the front the list.
Below we will define a type of binary trees, ``BinTree``, whose elements are generated by
starting with the empty tree and building new trees by attaching a new node to two existing trees.

In Lean, one can define inductive types whose objects are infinite, like countably branching
well-founded trees.
Finite inductive definitions are commonly used in discrete mathematics, however,
especially in those branches of discrete mathematics that are relevant to computer science.
Lean provides not only the means to define such types, but also principles of induction and
definition by recursion. For example, the data type ``List α`` is defined inductively:
EXAMPLES: -/
-- QUOTE:
namespace MyListSpace

inductive List (α : Type*) where
  | nil  : List α
  | cons : α → List α → List α

end MyListSpace
-- QUOTE.

/- TEXT:
The inductive definition says that every element of ``List α`` is either ``nil``, the empty list,
or ``cons a as``, where ``a`` is an element of ``α`` and ``as`` is a list of elements of ``α``.
The constructors are properly named ``List.nil`` and ``List.cons``, but you can use the shorter
notation with the ``List`` namespace is open.
When the ``List`` namespace is *not* open, you can write ``.nil`` and ``.cons a as`` anywhere
that ``Lean`` expects a list, and Lean will automatically insert the ``List`` qualifier.
Throughout this section, we will put temporary definitions in separate namespaces like
``MyListSpace`` to avoid conflicts with the standard library. Outside the temporary namespace,
we revert to using the standard library definitions.

Lean defines the notation ``[]`` for ``nil`` and ``::`` for ``cons``, and you can write
``[a, b, c]`` for ``a :: b :: c :: []``. The append and map functions are defined
recursively as follows:
EXAMPLES: -/
namespace MyListSpace2

-- QUOTE:
def append {α : Type*} : List α → List α → List α
  | [],      bs => bs
  | a :: as, bs => a :: (append as bs)

def map {α β : Type*} (f : α → β) : List α → List β
  | []      => []
  | a :: as => f a :: map f as

#eval append [1, 2, 3] [4, 5, 6]
#eval map (fun n => n^2) [1, 2, 3, 4, 5]
-- QUOTE.

/- TEXT:
Notice that there is a base case and a recursive case.
In each case, the two defining clauses hold definitionally:
EXAMPLES: -/
-- QUOTE:
theorem nil_append {α : Type*} (as : List α) : append [] as = as := rfl

theorem cons_append {α : Type*} (a : α) (as : List α) (bs : List α) :
    append (a :: as) bs = a :: (append as bs) := rfl

theorem map_nil {α β : Type*} (f : α → β) : map f [] = [] := rfl

theorem map_cons {α β : Type*} (f : α → β) (a : α) (as : List α) :
    map f (a :: as) = f a :: map f as := rfl
-- QUOTE.

end MyListSpace2

/- TEXT:
The functions ``append`` and ``map`` are defined in the standard library, and ``append as bs``
can be written as ``as ++ bs``.

Lean allows you to write proofs by induction following the structure of the definition.
BOTH: -/
namespace MyListSpace3

-- QUOTE:
variable {α β γ : Type*}
variable (as bs cs : List α)
variable (a b c : α)

open List

-- EXAMPLES:
theorem append_nil : ∀ as : List α, as ++ [] = as
  | [] => rfl
  | a :: as => by rw [cons_append, append_nil as]

theorem map_map (f : α → β) (g : β → γ) :
    ∀ as : List α, map g (map f as) = map (g ∘ f) as
  | [] => rfl
  | a :: as => by rw [map_cons, map_cons, map_cons, map_map f g as]; rfl
-- QUOTE.

/- TEXT:
You can also use the ``induction'`` tactic.

EXAMPLES: -/
theorem append_nil' : as ++ [] = as := by
  induction' as with a as ih
  . rfl
  . rw [cons_append, ih]

theorem map_map' (f : α → β) (g : β → γ) (as : List α) :
    map g (map f as) = map (g ∘ f) as := by
  induction' as with a as ih
  . rfl
  . simp [map, ih]

/- TEXT:
Of course, these theorems are already in the standard library. As an exercise,
try defining a function ``reverse`` in the ``MyListSpace3`` namespace (to avoid
conflicting with the standard ``List.reverse``) that reverses a list.
You can use ``#eval reverse [1, 2, 3, 4, 5]`` to test it out.
The most straightforward definition of
``reverse`` requires quadratic time, but don't worry about that.
You can jump to the definition of ``List.reverse`` in the standard library to see a
linear-time implementation.
Try proving ``reverse (as ++ bs) = reverse bs ++ reverse as`` and
``reverse (reverse as) = as``.
You can use ``cons_append`` and ``append_assoc``, but you
You may need to come up with auxiliary lemmas and prove them.
EXAMPLES: -/
-- QUOTE:
def reverseαα : List α → List α := sorry

theorem reverse_appendαα (as bs : List α) : reverse (as ++ bs) = reverse bs ++ reverse as := by
  sorry

theorem reverse_reverseαα (as : List α) : reverse (reverse as) = as := by sorry
-- QUOTE.
-- SOLUTIONS:
def reverse : List α → List α
  | []      => []
  | a :: as => reverse as ++ [a]

theorem reverse_append (as bs : List α) : reverse (as ++ bs) = reverse bs ++ reverse as := by
  induction' as with a as ih
  . rw [nil_append, reverse, append_nil]
  rw [cons_append, reverse, ih, reverse, append_assoc]

theorem reverse_reverse (as : List α) : reverse (reverse as) = as := by
  induction' as with a as ih
  . rfl
  rw [reverse, reverse_append, ih, reverse, reverse, nil_append, cons_append, nil_append]
-- BOTH:

end MyListSpace3

/- TEXT:
For another example, consider the following inductive definition of binary trees together with
functions to compute the size and depth of a binary tree.
BOTH: -/
-- QUOTE:
inductive BinTree where
  | empty : BinTree
  | node  : BinTree → BinTree → BinTree

namespace BinTree

def size : BinTree → ℕ
  | empty    => 0
  | node l r => size l + size r + 1

def depth : BinTree → ℕ
  | empty    => 0
  | node l r => max (depth l) (depth r) + 1
-- QUOTE.

/- TEXT:
It is convenient to count the empty binary tree as a binary tree of size 0 and depth 0.
In the literature, this data type is sometimes called the *extended binary trees*.
Including the empty tree means, for example, that we can define the tree
``node empty (node empty empty)`` consisting of a root node, and empty left subtree,
and a right subtree consisting of a single node.

Here is an important inequality relating the size and the depth:
EXAMPLES: -/
-- QUOTE:
theorem size_le : ∀ t : BinTree, size t ≤ 2^depth t - 1
  | empty    => Nat.zero_le _
  | node l r => by
    simp only [depth, size]
    calc l.size + r.size + 1
      ≤ (2^l.depth - 1) + (2^r.depth - 1) + 1 := by
          gcongr <;> apply size_le
    _ ≤ (2 ^ max l.depth r.depth - 1) + (2 ^ max l.depth r.depth - 1) + 1 := by
          gcongr <;> simp
    _ ≤ 2 ^ (max l.depth r.depth + 1) - 1 := by
          have : 0 < 2 ^ max l.depth r.depth := by simp
          omega
-- QUOTE.

/- TEXT:
Try proving the following inequality, which is somewhat easier.
Remember, if you do a proof by induction as in the previous theorem,
you have to delete the ``:= by``.
EXAMPLES: -/
-- QUOTE:
theorem depth_le_sizeαα : ∀ t : BinTree, depth t ≤ size t := by sorry
-- QUOTE.

-- SOLUTIONS:
theorem depth_le_size : ∀ t : BinTree, depth t ≤ size t
  | BinTree.empty => Nat.zero_le _
  | BinTree.node l r => by
    simp only [depth, size, add_le_add_iff_right, max_le_iff]
    constructor
    . apply le_add_right
      apply depth_le_size
    . apply le_add_left
      apply depth_le_size

/- TEXT:
Also define the ``flip`` operation on binary trees, which recursively swaps the
left and right subtrees.
EXAMPLES: -/
-- QUOTE:
def flipαα : BinTree → BinTree := sorry
-- QUOTE.

/- TEXT:
If you did it right, the proof of the following should be `rfl`.
EXAMPLES: -/
-- QUOTE:
example: flipαα  (node (node empty (node empty empty)) (node empty empty)) =
    node (node empty empty) (node (node empty empty) empty) := sorry
-- QUOTE.

/- TEXT:
Prove the following:
EXAMPLES: -/
-- QUOTE:
theorem size_flipαα : ∀ t, size (flipαα t) = size t := by sorry
-- QUOTE.
-- SOLUTIONS:
def flip : BinTree → BinTree
  | empty => empty
  | node l r => node (flip r) (flip l)

example: flip  (node (node empty (node empty empty)) (node empty empty)) =
    node (node empty empty) (node (node empty empty) empty) := rfl

theorem size_flip : ∀ t, size (flip t) = size t
  | empty => rfl
  | node l r => by
      dsimp [size, flip]
      rw [size_flip l, size_flip r]; omega

-- BOTH:
end BinTree

/- TEXT:
We close this section with some formal logic.
The following is an inductive definition of propositional formulas.
BOTH: -/
-- QUOTE:
inductive PropForm : Type where
  | var (n : ℕ)           : PropForm
  | fls                   : PropForm
  | conj (A B : PropForm) : PropForm
  | disj (A B : PropForm) : PropForm
  | impl (A B : PropForm) : PropForm
-- QUOTE.
namespace PropForm

/- TEXT:
Every propositional formula is either a variable ``var n``, the constant false
``fls``, or a compound formula of the form ``conj A B``, ``disj A B``, or ``impl A B``.
With ordinary mathematical notation, these are commonly written :math:`p_n`, :math:`\bot`, :math:`A \wedge B`,
:math:`A \vee B`, and :math:`A \to B`, respectively.
The other propositional connectives can be defined in terms of these; for example, we can
define :math:`\neg A` as :math:`A \to \bot` and :math:`A \leftrightarrow B` as
:math:`(A \to B) \wedge (B \to A)`.

Having defined the data type of propositional formulas, we define what it means to evaluate a
propositional formula with respect to an
assignment ``v`` of Boolean truth values to the variables.
BOTH: -/
-- QUOTE:
def eval : PropForm → (ℕ → Bool) → Bool
  | var n,    v => v n
  | fls,      _ => false
  | conj A B, v => A.eval v && B.eval v
  | disj A B, v => A.eval v || B.eval v
  | impl A B, v => ! A.eval v || B.eval v
-- QUOTE.

/- TEXT:
The next definition specifies the set of variables occurring in a formula, and the subsequent
theorem shows that evaluating a formula on two truth assignments that agree on its variables
yields that same value.
BOTH: -/
-- QUOTE:
def vars : PropForm → Finset ℕ
  | var n    => {n}
  | fls      => ∅
  | conj A B => A.vars ∪ B.vars
  | disj A B => A.vars ∪ B.vars
  | impl A B => A.vars ∪ B.vars

-- EXAMPLES:
theorem eval_eq_eval : ∀ (A : PropForm) (v1 v2 : ℕ → Bool),
    (∀ n ∈ A.vars, v1 n = v2 n) → A.eval v1 = A.eval v2
  | var n, v1, v2, h    => by simp_all [vars, eval, h]
  | fls, v1, v2, h      => by simp_all [eval]
  | conj A B, v1, v2, h => by
      simp_all [vars, eval, eval_eq_eval A v1 v2, eval_eq_eval B v1 v2]
  | disj A B, v1, v2, h => by
      simp_all [vars, eval, eval_eq_eval A v1 v2, eval_eq_eval B v1 v2]
  | impl A B, v1, v2, h => by
      simp_all [vars, eval, eval_eq_eval A v1 v2, eval_eq_eval B v1 v2]
-- QUOTE.

/- TEXT:
Noticing the repetition, we can be clever about the use of automation.
EXAMPLES: -/
-- QUOTE:
theorem eval_eq_eval' (A : PropForm) (v1 v2 : ℕ → Bool) (h : ∀ n ∈ A.vars, v1 n = v2 n) :
    A.eval v1 = A.eval v2 := by
  cases A <;> simp_all [eval, vars, fun A => eval_eq_eval' A v1 v2]
-- QUOTE.

/- TEXT:
The function ``subst A m C`` describes the result of substituting the formula ``C`` for every
occurrence of the variable ``var m`` in the formula ``A``.
BOTH: -/
-- QUOTE:
def subst : PropForm → ℕ → PropForm → PropForm
  | var n,    m, C => if n = m then C else var n
  | fls,      _, _ => fls
  | conj A B, m, C => conj (A.subst m C) (B.subst m C)
  | disj A B, m, C => disj (A.subst m C) (B.subst m C)
  | impl A B, m, C => impl (A.subst m C) (B.subst m C)
-- QUOTE.

/- TEXT:
As an example, show that substituting for a variable that does not occur in a formula
has no effect:
EXAMPLES: -/
-- QUOTE:
theorem subst_eq_of_not_mem_varsαα :
    ∀ (A : PropForm) (n : ℕ) (C : PropForm), n ∉ A.vars → A.subst n C = A := sorry
-- QUOTE.

-- SOLUTIONS:
theorem subst_eq_of_not_mem_vars :
    ∀ (A : PropForm) (n : ℕ) (C : PropForm), n ∉ A.vars → A.subst n C = A
  | var m, n, C, h => by simp_all [subst, vars]; tauto
  | fls, n, C, _ => by rw [subst]
  | conj A B, n, C, h => by
    simp_all [subst, vars, subst_eq_of_not_mem_vars A, subst_eq_of_not_mem_vars B]
  | disj A B, n, C, h => by
    simp_all [subst, vars, subst_eq_of_not_mem_vars A, subst_eq_of_not_mem_vars B]
  | impl A B, n, C, h => by
    simp_all [subst, vars, subst_eq_of_not_mem_vars A, subst_eq_of_not_mem_vars B]

-- alternative proof:
theorem subst_eq_of_not_mem_vars' (A : PropForm) (n : ℕ) (C : PropForm):
    n ∉ A.vars → A.subst n C = A := by
  cases A <;> simp_all [subst, vars, subst_eq_of_not_mem_vars']; tauto

/- TEXT:
The following theorem says something more subtle and interesting: evaluating
``A.subst n C`` on a truth assignment ``v`` is the same as evaluating
``A`` on a truth assignment that assigns the value of ``C`` to ``var n``.
See if you can prove it.
EXAMPLES: -/
-- QUOTE:
theorem subst_eval_eqαα : ∀ (A : PropForm) (n : ℕ) (C : PropForm) (v : ℕ → Bool),
  (A.subst n C).eval v = A.eval (fun m => if m = n then C.eval v else v m) := sorry
-- QUOTE.
-- SOLUTIONS:
theorem subst_eval_eq : ∀ (A : PropForm) (n : ℕ) (C : PropForm) (v : ℕ → Bool),
  (A.subst n C).eval v = A.eval (fun m => if m = n then C.eval v else v m)
  | var m, n, C, v => by
    simp [subst, eval]
    split <;> simp [eval]
  | fls, n, C, v => by
    simp [subst, eval]
  | conj A B, n, C, v => by
    simp [subst, eval, subst_eval_eq A n C v, subst_eval_eq B n C v]
  | disj A B, n, C, v => by
    simp [subst, eval, subst_eval_eq A n C v, subst_eval_eq B n C v]
  | impl A B, n, C, v => by
    simp [subst, eval, subst_eval_eq A n C v, subst_eval_eq B n C v]

-- alternative proof:
theorem subst_eval_eq' (A : PropForm) (n : ℕ) (C : PropForm) (v : ℕ → Bool) :
    (A.subst n C).eval v = A.eval (fun m => if m = n then C.eval v else v m) := by
  cases A <;> simp [subst, eval, subst_eval_eq'];
    split <;> simp_all [eval]
-- BOTH:

end PropForm
