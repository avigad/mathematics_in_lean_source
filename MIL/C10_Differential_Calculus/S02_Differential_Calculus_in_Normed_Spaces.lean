import MIL.Common
import Mathlib.Analysis.NormedSpace.BanachSteinhaus
import Mathlib.Analysis.NormedSpace.FiniteDimension
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv
import Mathlib.Analysis.Calculus.ContDiff.RCLike
import Mathlib.Analysis.Calculus.FDeriv.Prod


open Set Filter

open Topology Filter

noncomputable section

/- TEXT:
.. index:: normed space

.. _normed_spaces:

Differential Calculus in Normed Spaces
--------------------------------------

Normed spaces
^^^^^^^^^^^^^

Differentiation can be generalized beyond ``‚Ñù`` using the notion of a
*normed vector space*, which encapsulates both direction and distance.
We start with the notion of a *normed group*, which as an additive commutative
group equipped with a real-valued norm function
satisfying the following conditions.
EXAMPLES: -/
section

-- QUOTE:
variable {E : Type*} [NormedAddCommGroup E]

example (x : E) : 0 ‚â§ ‚Äñx‚Äñ :=
  norm_nonneg x

example {x : E} : ‚Äñx‚Äñ = 0 ‚Üî x = 0 :=
  norm_eq_zero

example (x y : E) : ‚Äñx + y‚Äñ ‚â§ ‚Äñx‚Äñ + ‚Äñy‚Äñ :=
  norm_add_le x y
-- QUOTE.

/- TEXT:
Every normed space is a metric space with distance function
:math:`d(x, y) = \| x - y \|`, and hence it is also a topological space.
Lean and Mathlib know this.
EXAMPLES: -/
-- QUOTE:
example : MetricSpace E := by infer_instance

example {X : Type*} [TopologicalSpace X] {f : X ‚Üí E} (hf : Continuous f) :
    Continuous fun x ‚Ü¶ ‚Äñf x‚Äñ :=
  hf.norm
-- QUOTE.

/- TEXT:
In order to use the notion of a norm with concepts from linear algebra,
we add the assumption ``NormedSpace ‚Ñù E`` on top of ``NormedAddGroup E``.
This stipulates that ``E`` is a vector space over ``‚Ñù`` and that
scalar multiplication satisfies the following condition.
EXAMPLES: -/
-- QUOTE:
variable [NormedSpace ‚Ñù E]

example (a : ‚Ñù) (x : E) : ‚Äña ‚Ä¢ x‚Äñ = |a| * ‚Äñx‚Äñ :=
  norm_smul a x
-- QUOTE.

/- TEXT:
A complete normed space is known as a *Banach space*.
Every finite-dimensional vector space is complete.
EXAMPLES: -/
-- QUOTE:
example [FiniteDimensional ‚Ñù E] : CompleteSpace E := by infer_instance
-- QUOTE.

/- TEXT:
In all the previous examples, we used the real numbers as the base field.
More generally, we can make sense of calculus with a vector space over any
*nontrivially normed field*. These are fields that are equipped with a
real-valued norm that is multiplicative and has the property that
not every element has norm zero or one
(equivalently, there is an element whose norm is bigger than one).
EXAMPLES: -/
-- QUOTE:
example (ùïú : Type*) [NontriviallyNormedField ùïú] (x y : ùïú) : ‚Äñx * y‚Äñ = ‚Äñx‚Äñ * ‚Äñy‚Äñ :=
  norm_mul x y

example (ùïú : Type*) [NontriviallyNormedField ùïú] : ‚àÉ x : ùïú, 1 < ‚Äñx‚Äñ :=
  NormedField.exists_one_lt_norm ùïú
-- QUOTE.

/- TEXT:
A finite-dimensional vector space over a nontrivially normed field is
complete as long as the field itself is complete.
EXAMPLES: -/
-- QUOTE:
example (ùïú : Type*) [NontriviallyNormedField ùïú] (E : Type*) [NormedAddCommGroup E]
    [NormedSpace ùïú E] [CompleteSpace ùïú] [FiniteDimensional ùïú E] : CompleteSpace E :=
  FiniteDimensional.complete ùïú E
-- QUOTE.

end

/- TEXT:
Continuous linear maps
^^^^^^^^^^^^^^^^^^^^^^

We now turn to the morphisms in the category of normed spaces, namely,
continuous linear maps.
In Mathlib, the type of ``ùïú``-linear continuous maps between normed spaces
``E`` and ``F`` is written ``E ‚ÜíL[ùïú] F``.
They are implemented as *bundled maps*, which means that an element of this type
a structure that that includes the function itself and the properties
of being linear and continuous.
Lean will insert a coercion so that a continuous linear map can be treated
as a function.
EXAMPLES: -/
section

-- QUOTE:
variable {ùïú : Type*} [NontriviallyNormedField ùïú] {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]

example : E ‚ÜíL[ùïú] E :=
  ContinuousLinearMap.id ùïú E

example (f : E ‚ÜíL[ùïú] F) : E ‚Üí F :=
  f

example (f : E ‚ÜíL[ùïú] F) : Continuous f :=
  f.cont

example (f : E ‚ÜíL[ùïú] F) (x y : E) : f (x + y) = f x + f y :=
  f.map_add x y

example (f : E ‚ÜíL[ùïú] F) (a : ùïú) (x : E) : f (a ‚Ä¢ x) = a ‚Ä¢ f x :=
  f.map_smul a x
-- QUOTE.

/- TEXT:
Continuous linear maps have an operator norm that is characterized by the
following properties.
EXAMPLES: -/
-- QUOTE:
variable (f : E ‚ÜíL[ùïú] F)

example (x : E) : ‚Äñf x‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñx‚Äñ :=
  f.le_op_norm x

example {M : ‚Ñù} (hMp : 0 ‚â§ M) (hM : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ M * ‚Äñx‚Äñ) : ‚Äñf‚Äñ ‚â§ M :=
  f.op_norm_le_bound hMp hM
-- QUOTE.

end

/- TEXT:
There is also a notion of bundled continuous linear *isomorphism*.
Their type of such isomorphisms is ``E ‚âÉL[ùïú] F``.

As a challenging exercise, you can prove the Banach-Steinhaus theorem, also
known as the Uniform Boundedness Principle.
The principle states that a family of continuous linear maps from a Banach space
into a normed space is pointwise
bounded, then the norms of these linear maps are uniformly bounded.
The main ingredient is Baire's theorem
``nonempty_interior_of_iUnion_of_closed``. (You proved a version of this in the topology chapter.)
Minor ingredients include ``continuous_linear_map.opNorm_le_of_shell``,
``interior_subset`` and ``interior_iInter_subset`` and ``is_closed_le``.
BOTH: -/
section

-- QUOTE:
variable {ùïú : Type*} [NontriviallyNormedField ùïú] {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]

open Metric

-- EXAMPLES:
example {Œπ : Type*} [CompleteSpace E] {g : Œπ ‚Üí E ‚ÜíL[ùïú] F} (h : ‚àÄ x, ‚àÉ C, ‚àÄ i, ‚Äñg i x‚Äñ ‚â§ C) :
    ‚àÉ C', ‚àÄ i, ‚Äñg i‚Äñ ‚â§ C' := by
  -- sequence of subsets consisting of those `x : E` with norms `‚Äñg i x‚Äñ` bounded by `n`
  let e : ‚Ñï ‚Üí Set E := fun n ‚Ü¶ ‚ãÇ i : Œπ, { x : E | ‚Äñg i x‚Äñ ‚â§ n }
  -- each of these sets is closed
  have hc : ‚àÄ n : ‚Ñï, IsClosed (e n)
  sorry
  -- the union is the entire space; this is where we use `h`
  have hU : (‚ãÉ n : ‚Ñï, e n) = univ
  sorry
  /- apply the Baire category theorem to conclude that for some `m : ‚Ñï`,
       `e m` contains some `x` -/
  obtain ‚ü®m, x, hx‚ü© : ‚àÉ m, ‚àÉ x, x ‚àà interior (e m) := sorry
  obtain ‚ü®Œµ, Œµ_pos, hŒµ‚ü© : ‚àÉ Œµ > 0, ball x Œµ ‚äÜ interior (e m) := sorry
  obtain ‚ü®k, hk‚ü© : ‚àÉ k : ùïú, 1 < ‚Äñk‚Äñ := sorry
  -- show all elements in the ball have norm bounded by `m` after applying any `g i`
  have real_norm_le : ‚àÄ z ‚àà ball x Œµ, ‚àÄ (i : Œπ), ‚Äñg i z‚Äñ ‚â§ m
  sorry
  have Œµk_pos : 0 < Œµ / ‚Äñk‚Äñ := sorry
  refine' ‚ü®(m + m : ‚Ñï) / (Œµ / ‚Äñk‚Äñ), fun i ‚Ü¶ ContinuousLinearMap.opNorm_le_of_shell Œµ_pos _ hk _‚ü©
  sorry
  sorry
-- QUOTE.

-- SOLUTIONS:
example {Œπ : Type*} [CompleteSpace E] {g : Œπ ‚Üí E ‚ÜíL[ùïú] F} (h : ‚àÄ x, ‚àÉ C, ‚àÄ i, ‚Äñg i x‚Äñ ‚â§ C) :
    ‚àÉ C', ‚àÄ i, ‚Äñg i‚Äñ ‚â§ C' := by
  -- sequence of subsets consisting of those `x : E` with norms `‚Äñg i x‚Äñ` bounded by `n`
  let e : ‚Ñï ‚Üí Set E := fun n ‚Ü¶ ‚ãÇ i : Œπ, { x : E | ‚Äñg i x‚Äñ ‚â§ n }
  -- each of these sets is closed
  have hc : ‚àÄ n : ‚Ñï, IsClosed (e n) := fun i ‚Ü¶
    isClosed_iInter fun i ‚Ü¶ isClosed_le (g i).cont.norm continuous_const
  -- the union is the entire space; this is where we use `h`
  have hU : (‚ãÉ n : ‚Ñï, e n) = univ := by
    refine' eq_univ_of_forall fun x ‚Ü¶ _
    rcases h x with ‚ü®C, hC‚ü©
    obtain ‚ü®m, hm‚ü© := exists_nat_ge C
    exact ‚ü®e m, mem_range_self m, mem_iInter.mpr fun i ‚Ü¶ le_trans (hC i) hm‚ü©
  /- apply the Baire category theorem to conclude that for some `m : ‚Ñï`,
       `e m` contains some `x` -/
  obtain ‚ü®m : ‚Ñï, x : E, hx : x ‚àà interior (e m)‚ü© := nonempty_interior_of_iUnion_of_closed hc hU
  obtain ‚ü®Œµ, Œµ_pos, hŒµ : ball x Œµ ‚äÜ interior (e m)‚ü© := isOpen_iff.mp isOpen_interior x hx
  obtain ‚ü®k : ùïú, hk : 1 < ‚Äñk‚Äñ‚ü© := NormedField.exists_one_lt_norm ùïú
  -- show all elements in the ball have norm bounded by `m` after applying any `g i`
  have real_norm_le : ‚àÄ z ‚àà ball x Œµ, ‚àÄ (i : Œπ), ‚Äñg i z‚Äñ ‚â§ m := by
    intro z hz i
    replace hz := mem_iInter.mp (interior_iInter_subset _ (hŒµ hz)) i
    apply interior_subset hz
  have Œµk_pos : 0 < Œµ / ‚Äñk‚Äñ := div_pos Œµ_pos (zero_lt_one.trans hk)
  refine' ‚ü®(m + m : ‚Ñï) / (Œµ / ‚Äñk‚Äñ), fun i ‚Ü¶ ContinuousLinearMap.opNorm_le_of_shell Œµ_pos _ hk _‚ü©
  ¬∑ exact div_nonneg (Nat.cast_nonneg _) Œµk_pos.le
  intro y le_y y_lt
  calc
    ‚Äñg i y‚Äñ = ‚Äñg i (y + x) - g i x‚Äñ := by rw [(g i).map_add, add_sub_cancel_right]
    _ ‚â§ ‚Äñg i (y + x)‚Äñ + ‚Äñg i x‚Äñ := (norm_sub_le _ _)
    _ ‚â§ m + m :=
      (add_le_add (real_norm_le (y + x) (by rwa [add_comm, add_mem_ball_iff_norm]) i)
        (real_norm_le x (mem_ball_self Œµ_pos) i))
    _ = (m + m : ‚Ñï) := by norm_cast
    _ ‚â§ (m + m : ‚Ñï) * (‚Äñy‚Äñ / (Œµ / ‚Äñk‚Äñ)) :=
      (le_mul_of_one_le_right (Nat.cast_nonneg _)
        ((one_le_div <| div_pos Œµ_pos (zero_lt_one.trans hk)).2 le_y))
    _ = (m + m : ‚Ñï) / (Œµ / ‚Äñk‚Äñ) * ‚Äñy‚Äñ := (mul_comm_div _ _ _).symm


-- BOTH:
end

/- TEXT:
Asymptotic comparisons
^^^^^^^^^^^^^^^^^^^^^^

Defining differentiability also requires asymptotic comparisons.
Mathlib has an extensive library covering the big O and little o relations,
whose definitions are shown below.
Opening the ``asymptotics`` locale allows us to use the corresponding
notation.
Here we will only use little o to define differentiability.
EXAMPLES: -/
-- QUOTE:
open Asymptotics

example {Œ± : Type*} {E : Type*} [NormedGroup E] {F : Type*} [NormedGroup F] (c : ‚Ñù)
    (l : Filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : IsBigOWith c l f g ‚Üî ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=
  isBigOWith_iff

example {Œ± : Type*} {E : Type*} [NormedGroup E] {F : Type*} [NormedGroup F]
    (l : Filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : f =O[l] g ‚Üî ‚àÉ C, IsBigOWith C l f g :=
  isBigO_iff_isBigOWith

example {Œ± : Type*} {E : Type*} [NormedGroup E] {F : Type*} [NormedGroup F]
    (l : Filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : f =o[l] g ‚Üî ‚àÄ C > 0, IsBigOWith C l f g :=
  isLittleO_iff_forall_isBigOWith

example {Œ± : Type*} {E : Type*} [NormedAddCommGroup E] (l : Filter Œ±) (f g : Œ± ‚Üí E) :
    f ~[l] g ‚Üî (f - g) =o[l] g :=
  Iff.rfl
-- QUOTE.

/- TEXT:
Differentiability
^^^^^^^^^^^^^^^^^

We are now ready to discuss differentiable functions between normed spaces.
In analogy the elementary one-dimensional,
Mathlib defines a predicate ``HasFDerivAt`` and a function ``fderiv``.
Here the letter
"f" stands for *Fr√©chet*.
EXAMPLES: -/
section

-- QUOTE:
open Topology

variable {ùïú : Type*} [NontriviallyNormedField ùïú] {E : Type*} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]

example (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (x‚ÇÄ : E) :
    HasFDerivAt f f' x‚ÇÄ ‚Üî (fun x ‚Ü¶ f x - f x‚ÇÄ - f' (x - x‚ÇÄ)) =o[ùìù x‚ÇÄ] fun x ‚Ü¶ x - x‚ÇÄ :=
  hasFDerivAtFilter_iff_isLittleO ..

example (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (x‚ÇÄ : E) (hff' : HasFDerivAt f f' x‚ÇÄ) : fderiv ùïú f x‚ÇÄ = f' :=
  hff'.fderiv
-- QUOTE.

/- TEXT:
We also have iterated derivatives that take values in the type of multilinear maps
``E [√ón]‚ÜíL[ùïú] F``,
and we have continuously differential functions.
The type ``WithTop ‚Ñï`` is ``‚Ñï`` with an additional element ``‚ä§`` that
is bigger than every natural number.
So :math:`\mathcal{C}^\infty` functions are functions ``f`` that satisfy
``ContDiff ùïú ‚ä§ f``.
EXAMPLES: -/
-- QUOTE:
example (n : ‚Ñï) (f : E ‚Üí F) : E ‚Üí E[√ón]‚ÜíL[ùïú] F :=
  iteratedFDeriv ùïú n f

example (n : WithTop ‚Ñï) {f : E ‚Üí F} :
    ContDiff ùïú n f ‚Üî
      (‚àÄ m : ‚Ñï, (m : WithTop ‚Ñï) ‚â§ n ‚Üí Continuous fun x ‚Ü¶ iteratedFDeriv ùïú m f x) ‚àß
        ‚àÄ m : ‚Ñï, (m : WithTop ‚Ñï) < n ‚Üí Differentiable ùïú fun x ‚Ü¶ iteratedFDeriv ùïú m f x :=
  contDiff_iff_continuous_differentiable
-- QUOTE.

/- TEXT:
There is a stricter notion of differentiability called
``HasStrictFDerivAt``, which is used in the statement
of the inverse function theorem and the statement of the implicit function
theorem, both of which are in Mathlib.
Over ``‚Ñù`` or ``‚ÑÇ``, continuously differentiable
functions are strictly differentiable.
EXAMPLES: -/
-- QUOTE:
example {ùïÇ : Type*} [RCLike ùïÇ] {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïÇ E] {F : Type*}
    [NormedAddCommGroup F] [NormedSpace ùïÇ F] {f : E ‚Üí F} {x : E} {n : WithTop ‚Ñï}
    (hf : ContDiffAt ùïÇ n f x) (hn : 1 ‚â§ n) : HasStrictFDerivAt f (fderiv ùïÇ f x) x :=
  hf.hasStrictFDerivAt hn
-- QUOTE.

/- TEXT:
The local inverse theorem is stated using an operation that produces an
inverse function from a
function and the assumptions that the function is strictly differentiable at a
point ``a`` and that its derivative is an isomorphism.

The first example below gets this local inverse.
The next one states that it is indeed a local inverse
from the left and from the right, and that it is strictly differentiable.
EXAMPLES: -/
-- QUOTE:
section LocalInverse
variable [CompleteSpace E] {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {a : E}

example (hf : HasStrictFDerivAt f (f' : E ‚ÜíL[ùïú] F) a) : F ‚Üí E :=
  HasStrictFDerivAt.localInverse f f' a hf

example (hf : HasStrictFDerivAt f (f' : E ‚ÜíL[ùïú] F) a) :
    ‚àÄ·∂† x in ùìù a, hf.localInverse f f' a (f x) = x :=
  hf.eventually_left_inverse

example (hf : HasStrictFDerivAt f (f' : E ‚ÜíL[ùïú] F) a) :
    ‚àÄ·∂† x in ùìù (f a), f (hf.localInverse f f' a x) = x :=
  hf.eventually_right_inverse

example {f : E ‚Üí F} {f' : E ‚âÉL[ùïú] F} {a : E}
  (hf : HasStrictFDerivAt f (f' : E ‚ÜíL[ùïú] F) a) :
    HasStrictFDerivAt (HasStrictFDerivAt.localInverse f f' a hf) (f'.symm : F ‚ÜíL[ùïú] E) (f a) :=
  HasStrictFDerivAt.to_localInverse hf

end LocalInverse
-- QUOTE.

/- TEXT:
This has been only a quick tour of the differential calculus in Mathlib.
The library contains many variations that we have not discussed.
For example, you may want to use one-sided derivatives in the
one-dimensional setting. The means to do so are found in Mathlib in a more
general context;
see ``HasFDerivWithinAt`` or the even more general ``HasFDerivAtFilter``.
EXAMPLES: -/
#check HasFDerivWithinAt

#check HasFDerivAtFilter

end
