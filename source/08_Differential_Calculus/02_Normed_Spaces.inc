.. index:: normed space

.. _normed_spaces:

Differential Calculus in Normed Spaces
--------------------------------------

Normed spaces
^^^^^^^^^^^^^

Differentiation can be generalized beyond ``â„`` using the notion of a
*normed vector space*, which encapsulates both direction and distance.
We start with the notion of a *normed group*, which as an additive commutative
group equipped with a real-valued norm function
satisfying the following conditions.

.. code-block:: lean

  variables {E : Type*} [normed_group E]
  
  example (x : E) : 0 â‰¤ âˆ¥xâˆ¥ :=
  norm_nonneg x
  
  example {x : E} : âˆ¥xâˆ¥ = 0 â†” x = 0 :=
  norm_eq_zero
  
  example (x y : E) : âˆ¥x + yâˆ¥ â‰¤ âˆ¥xâˆ¥ + âˆ¥yâˆ¥ :=
  norm_add_le x y

Every normed space is a metric space with distance function
:math:`d(x, y) = \| x - y \|`, and hence it is also a topological space.
Lean and mathlib know this.

.. code-block:: lean

  example : metric_space E := by apply_instance
  
  example {X : Type*} [topological_space X] {f : X â†’ E} (hf : continuous f) :
    continuous (Î» x, âˆ¥f xâˆ¥) :=
  hf.norm

In order to use the notion of a norm with concepts from linear algebra,
we add the assumption ``normed_space â„ E`` on top of ``normed_group E``.
This stipulates that ``E`` is a vector space over ``â„`` and that
scalar multiplication satsifies the following condition.

.. code-block:: lean

  variables [normed_space â„ E]
  
  example (a : â„) (x : E) : âˆ¥a â€¢ xâˆ¥ = |a| * âˆ¥xâˆ¥ :=
  norm_smul a x

A complete normed space is known as a *Banach space*.
Every finite-dimensional vector space is complete.

.. code-block:: lean

  example [finite_dimensional â„ E] : complete_space E :=
  by apply_instance

In all the previous examples, we used the real numbers as the base field.
More generally, we can make sense of calculus with a vector space over any
*non-discrete normed field*. These are fields that are equipped with a
real-valued norm that is multiplicative and has the property that
not every element has norm zero or one
(equivalently, there is an element whose norm is bigger than one).

.. code-block:: lean

  example (ğ•œ : Type*) [nondiscrete_normed_field ğ•œ] (x y : ğ•œ) : âˆ¥x * yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥yâˆ¥ :=
  norm_mul x y
  
  example (ğ•œ : Type*) [nondiscrete_normed_field ğ•œ] : âˆƒ x : ğ•œ, 1 < âˆ¥xâˆ¥ :=
  normed_field.exists_one_lt_norm ğ•œ

A finite-dimensional vector space over a nondiscrete normed field is
complete as long as the field itself is complete.

.. code-block:: lean

  example (ğ•œ : Type*) [nondiscrete_normed_field ğ•œ] (E : Type*) [normed_group E]
    [normed_space ğ•œ E] [complete_space ğ•œ] [finite_dimensional ğ•œ E] : complete_space E :=
  finite_dimensional.complete ğ•œ E

Continuous linear maps
^^^^^^^^^^^^^^^^^^^^^^

We now turn to the morphisms in the category of normed spaces, namely,
continuous linear maps.
In mathlib, the type of ``ğ•œ``-linear continuous maps between normed spaces
``E`` and ``F`` is written ``E â†’L[ğ•œ] F``.
They are implemented as *bundled maps*, which means that an element of this type
a structure that that includes the function itself and the properties
of being linear and continuous.
Lean will insert a coercion so that a continuous linear map can be treated
as a function.

.. code-block:: lean

  variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
            {E : Type*} [normed_group E] [normed_space ğ•œ E]
            {F : Type*} [normed_group F] [normed_space ğ•œ F]
  
  example : E â†’L[ğ•œ] E := continuous_linear_map.id ğ•œ E
  
  example (f : E â†’L[ğ•œ] F) : E â†’ F :=
  f
  
  example (f : E â†’L[ğ•œ] F) : continuous f :=
  f.cont
  
  example (f : E â†’L[ğ•œ] F) (x y : E) : f (x + y) = f x + f y :=
  f.map_add x y
  
  example (f : E â†’L[ğ•œ] F) (a : ğ•œ) (x : E) : f (a â€¢ x) = a â€¢ f x :=
  f.map_smul a x

Continuous linear maps have an operator norm that is characterized by the
following properties.

.. code-block:: lean

  variables (f : E â†’L[ğ•œ] F)
  
  example (x : E) : âˆ¥f xâˆ¥ â‰¤ âˆ¥fâˆ¥ * âˆ¥xâˆ¥ :=
  f.le_op_norm x
  
  example {M : â„} (hMp: 0 â‰¤ M) (hM : âˆ€ x, âˆ¥f xâˆ¥ â‰¤ M * âˆ¥xâˆ¥) :
    âˆ¥fâˆ¥ â‰¤ M :=
  f.op_norm_le_bound hMp hM

There is also a notion of bundled continuous linear *isomorphism*.
Their type of such isomorphisms is ``E â‰ƒL[ğ•œ] F``.

As a challenging exercise, you can prove the Banach-Steinhaus theorem, also
known as the Uniform Boundedness Principle.
The principle states that a family of continuous linear maps from a Banach space
into a normed space is pointwise
bounded, then the norms of these linear maps are uniformly bounded.
The main ingredient is Baire's theorem
``nonempty_interior_of_Union_of_closed.`` (You proved a version of this in the topology chapter.)
Minor ingredients include ``continuous_linear_map.op_norm_le_of_shell``,
``interior_subset`` and ``interior_Inter_subset`` and ``is_closed_le``.

.. code-block:: lean

  variables
    {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
    {E : Type*} [normed_group E] [normed_space ğ•œ E]
    {F : Type*} [normed_group F] [normed_space ğ•œ F]
  
  open metric
  
  example {Î¹ : Type*} [complete_space E] {g : Î¹ â†’ E â†’L[ğ•œ] F}
    (h : âˆ€ x, âˆƒ C, âˆ€ i, âˆ¥g i xâˆ¥ â‰¤ C) :
    âˆƒ C', âˆ€ i, âˆ¥g iâˆ¥ â‰¤ C' :=
  begin
    /- sequence of subsets consisting of those `x : E` with norms `âˆ¥g i xâˆ¥` bounded by `n` -/
    let e : â„• â†’ set E := Î» n, â‹‚ i : Î¹, { x : E | âˆ¥g i xâˆ¥ â‰¤ n },
    /- each of these sets is closed -/
    have hc : âˆ€ n : â„•, is_closed (e n),
    sorry,
    /- the union is the entire space; this is where we use `h` -/
    have hU : (â‹ƒ n : â„•, e n) = univ,
    sorry,
    /- apply the Baire category theorem to conclude that for some `m : â„•`,
       `e m` contains some `x` -/
    obtain âŸ¨m, x, hxâŸ© : âˆƒ m, âˆƒ x, x âˆˆ interior (e m) := sorry,
    obtain âŸ¨Îµ, Îµ_pos, hÎµâŸ© : âˆƒ Îµ > 0, ball x Îµ âŠ† interior (e m) := sorry,
    obtain âŸ¨k, hkâŸ© : âˆƒ k : ğ•œ, 1 < âˆ¥kâˆ¥ := sorry,
    /- show all elements in the ball have norm bounded by `m` after applying any `g i` -/
    have real_norm_le : âˆ€ (z âˆˆ ball x Îµ) (i : Î¹), âˆ¥g i zâˆ¥ â‰¤ m,
    sorry,
    have Îµk_pos : 0 < Îµ / âˆ¥kâˆ¥ := sorry,
    refine âŸ¨(m + m : â„•) / (Îµ / âˆ¥kâˆ¥),
             Î» i, continuous_linear_map.op_norm_le_of_shell Îµ_pos _ hk _âŸ©,
    sorry,
    sorry
  end

Asymptotic comparisons
^^^^^^^^^^^^^^^^^^^^^^

Defining differentiability also requires asymptotic comparisons.
Mathlib has an extensive library covering the big O and little o relations,
whose definitions are shown below.
Opening the ``asymptotics`` locale allows us to use the corresponding
notation.
Here we will only use little o to define differentiability.

.. code-block:: lean

  open asymptotics
  open_locale asymptotics
  
  example {Î± : Type*} {E : Type*} [normed_group E] {F : Type*} [normed_group F]
    (c : â„) (l : filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) :
    is_O_with c l f g â†” âˆ€á¶  x in l, âˆ¥ f x âˆ¥ â‰¤ c * âˆ¥ g x âˆ¥ :=
  is_O_with_iff
  
  example {Î± : Type*} {E : Type*} [normed_group E] {F : Type*} [normed_group F]
    (c : â„) (l : filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) :
    f =O[l] g â†” âˆƒ C, is_O_with C l f g :=
  is_O_iff_is_O_with
  
  example {Î± : Type*} {E : Type*} [normed_group E] {F : Type*} [normed_group F]
    (c : â„) (l : filter Î±) (f : Î± â†’ E) (g : Î± â†’ F) :
    f =o[l] g â†” âˆ€ C > 0, is_O_with C l f g :=
  is_o_iff_forall_is_O_with
  
  example {Î± : Type*} {E : Type*} [normed_group E] (c : â„) (l : filter Î±) (f g : Î± â†’ E) :
    f ~[l] g â†” (f - g) =o[l] g :=
  iff.rfl

Differentiability
^^^^^^^^^^^^^^^^^

We are now ready to discuss differentiable functions between normed spaces.
In analogy the elementary one-dimensional,
mathlib defines a predicate ``has_fderiv_at`` and a function ``fderiv``.
Here the letter
"f" stands for *FrÃ©chet*.

.. code-block:: lean

  variables
    {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
    {E : Type*} [normed_group E] [normed_space ğ•œ E]
    {F : Type*} [normed_group F] [normed_space ğ•œ F]
  
  example (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (xâ‚€ : E) :
    has_fderiv_at f f' xâ‚€ â†” (Î» x, f x - f xâ‚€ - f' (x - xâ‚€)) =o[ğ“ xâ‚€] (Î» x, x - xâ‚€) :=
  iff.rfl
  
  example (f : E â†’ F) (f' : E â†’L[ğ•œ] F) (xâ‚€ : E) (hff' : has_fderiv_at f f' xâ‚€) :
    fderiv ğ•œ f xâ‚€ = f' :=
  hff'.fderiv

We also have iterated derivatives that take values in the type of multilinear maps
``E [Ã—n]â†’L[ğ•œ] F``,
and we have continuously differential functions.
The type ``with_top â„•`` is ``â„•`` with an additional element ``âŠ¤`` that
is bigger than every natural number.
So :math:`\mathcal{C}^\infty` functions are functions ``f`` that satisfy
``cont_diff ğ•œ âŠ¤ f``.

.. code-block:: lean

  example (n : â„•) (f : E â†’ F) : E â†’ (E [Ã—n]â†’L[ğ•œ] F) :=
  iterated_fderiv ğ•œ n f
  
  example (n : with_top â„•) {f : E â†’ F} :
    cont_diff ğ•œ n f â†”
      (âˆ€ (m : â„•), (m : with_top â„•) â‰¤ n â†’ continuous (Î» x, iterated_fderiv ğ•œ m f x))
    âˆ§ (âˆ€ (m : â„•), (m : with_top â„•) < n â†’ differentiable ğ•œ (Î» x, iterated_fderiv ğ•œ m f x)) :=
  cont_diff_iff_continuous_differentiable

There is a stricter notion of differentiability called
``has_strict_fderiv_at``, which is used in the statement
of the inverse function theorem and the statement of the implicit function
theorem, both of which are in mathlib.
Over ``â„`` or ``â„‚``, continuously differentiable
functions are strictly differentiable.

.. code-block:: lean

  example {ğ•‚ : Type*} [is_R_or_C ğ•‚] {E : Type*} [normed_group E] [normed_space ğ•‚ E]
    {F : Type*} [normed_group F] [normed_space ğ•‚ F]
    {f : E â†’ F} {x : E} {n : with_top â„•}
    (hf : cont_diff_at ğ•‚ n f x) (hn : 1 â‰¤ n) :
    has_strict_fderiv_at f (fderiv ğ•‚ f x) x :=
  hf.has_strict_fderiv_at hn

The local inverse theorem is stated using an operation that produces an
inverse function from a
function and the assumptions that the function is strictly differentiable at a
point ``a`` and that its derivative is an isomorphism.

The first example below gets this local inverse.
The next one states that it is indeed a local inverse
from the left and from the right, and that it is strictly differentiable.

.. code-block:: lean

  section local_inverse
  variables [complete_space E] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E}
  
  example (hf : has_strict_fderiv_at f â†‘f' a) : F â†’ E :=
  has_strict_fderiv_at.local_inverse f f' a hf
  
  example  (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
    âˆ€á¶  x in ğ“ a, hf.local_inverse f f' a (f x) = x :=
  hf.eventually_left_inverse
  
  example  (hf : has_strict_fderiv_at f (f' : E â†’L[ğ•œ] F) a) :
    âˆ€á¶  x in ğ“ (f a), f (hf.local_inverse f f' a x) = x :=
  hf.eventually_right_inverse
  
  example [complete_space E] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {a : E}
      (hf : has_strict_fderiv_at f â†‘f' a) :
    has_strict_fderiv_at (has_strict_fderiv_at.local_inverse f f' a hf)
      (f'.symm : F â†’L[ğ•œ] E) (f a) :=
  has_strict_fderiv_at.to_local_inverse hf
  
  end local_inverse

This has been only a quick tour of the differential calculus in mathlib.
The library contains many variations that we have not discussed.
For example, you may want to use one-sided derivatives in the
one-dimensional setting. The means to do so are found in mathlib in a more
general context;
see ``has_fderiv_within_at`` or the even more general ``has_fderiv_at_filter``.
