import analysis.normed_space.finite_dimension
import analysis.convolution
import measure_theory.function.jacobian
import measure_theory.integral.bochner
import measure_theory.measure.lebesgue

open set filter
open_locale topology filter ennreal
open measure_theory

noncomputable theory

variables {Î± : Type*} [measurable_space Î±]
variables {Î¼ : measure Î±}

/- TEXT:
.. _integration:

Integration
-----------

Now that we have measurable spaces and measures we can consider integrals.
As explained above, mathlib uses a very general notion of
integration that allows any Banach space as the target.
As usual, we don't want our notation to
carry around assumptions, so we define integration in such a way
that an integral is equal to zero if the function in question is
not integrable.
Most lemmas having to do with integrals have integrability assumptions.
EXAMPLES: -/
-- QUOTE:
section

variables {E : Type*} [normed_add_comm_group E] [normed_space â„ E] [complete_space E]
  {f : Î± â†’ E}

example {f g : Î± â†’ E} (hf : integrable f Î¼) (hg : integrable g Î¼) :
  âˆ« a, f a + g a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ + âˆ« a, g a âˆ‚Î¼ :=
integral_add hf hg
-- QUOTE.

/- TEXT:
As an example of the complex interactions between our various conventions, let us see how to integrate constant functions.
Recall that a measure ``Î¼`` takes values in ``â„â‰¥0âˆ``, the type of extended non-negative reals.
There is a function ``ennreal.to_real : â„â‰¥0âˆ â†’ â„`` which sends ``âŠ¤``,
the point at infinity, to zero.
For any ``s : set Î±``, if ``Î¼ s = âŠ¤``, then nonzero constant functions are not integrable on ``s``.
In that case, their integrals are equal to zero by definition, as is ``(Î¼ s).to_real``.
So in all cases we have the following lemma.
EXAMPLES: -/
-- QUOTE:
example {s : set Î±} (c : E) :
  âˆ« x in s, c âˆ‚Î¼ = (Î¼ s).to_real â€¢ c :=
set_integral_const c
-- QUOTE.

/- TEXT:
We now quickly explain how to access the most important theorems in integration theory, starting
with the dominated convergence theorem. There are several versions in mathlib,
and here we only show the most basic one.
EXAMPLES: -/
-- QUOTE:
example {F : â„• â†’ Î± â†’ E} {f : Î± â†’ E} (bound : Î± â†’ â„)
  (hmeas : âˆ€ n, ae_strongly_measurable (F n) Î¼)
  (hint : integrable bound Î¼)
  (hbound : âˆ€ n, âˆ€áµ a âˆ‚Î¼, â€–F n aâ€– â‰¤ bound a)
  (hlim : âˆ€áµ a âˆ‚Î¼, tendsto (Î» (n : â„•), F n a) at_top (ğ“ (f a))) :
  tendsto (Î» n, âˆ« a, F n a âˆ‚Î¼) at_top (ğ“ (âˆ« a, f a âˆ‚Î¼)) :=
tendsto_integral_of_dominated_convergence bound hmeas hint hbound hlim
-- QUOTE.

/- TEXT:
Then we have Fubini's theorem for integrals on product type.
EXAMPLES: -/
-- QUOTE:
example
  {Î± : Type*} [measurable_space Î±]
  {Î¼ : measure Î±} [sigma_finite Î¼]
  {Î² : Type*} [measurable_space Î²] {Î½ : measure Î²} [sigma_finite Î½]
  (f : Î± Ã— Î² â†’ E) (hf : integrable f (Î¼.prod Î½)) :
  âˆ« z, f z âˆ‚Î¼.prod Î½ = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ :=
integral_prod f hf
-- QUOTE.

end
/- TEXT:
There is a very general version of convolution that applies to any
continuous bilinear form.
EXAMPLES: -/
section
-- QUOTE:
open_locale convolution

-- EXAMPLES:
variables {ğ•œ : Type*} {G : Type*} {E : Type*} {E' : Type*} {F : Type*}
  [normed_add_comm_group E] [normed_add_comm_group E'] [normed_add_comm_group F]
  [nontrivially_normed_field ğ•œ]
  [normed_space ğ•œ E] [normed_space ğ•œ E'] [normed_space ğ•œ F]
  [measurable_space G] [normed_space â„ F] [complete_space F] [has_sub G]

example (f : G â†’ E) (g : G â†’ E') (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) (Î¼ : measure G) :
  f â‹†[L, Î¼] g = Î» x, âˆ« t, L (f t) (g (x - t)) âˆ‚Î¼ :=
rfl
-- QUOTE.

end
/- TEXT:
Finally, mathlib has a very general version of the change-of-variables formula.
In the statement below, ``borel_space E`` means the
:math:`\sigma`-algebra on ``E`` is generated by the open sets of ``E``,
and ``is_add_haar_measure Î¼`` means that the measure ``Î¼`` is left-invariant,
gives finite mass to compact sets, and give positive mass to open sets.
EXAMPLES: -/
-- QUOTE:
example {E : Type*}
  [normed_add_comm_group E] [normed_space â„ E] [finite_dimensional â„ E]
  [measurable_space E] [borel_space E] (Î¼ : measure E) [Î¼.is_add_haar_measure]
  {F : Type*} [normed_add_comm_group F] [normed_space â„ F] [complete_space F]
  {s : set E} {f : E â†’ E} {f' : E â†’ (E â†’L[â„] E)}
  (hs : measurable_set s)
  (hf : âˆ€ (x : E), x âˆˆ s â†’ has_fderiv_within_at f (f' x) s x)
  (h_inj : inj_on f s)
  (g : E â†’ F) :
  âˆ« x in f '' s, g x âˆ‚Î¼ = âˆ« x in s, |(f' x).det| â€¢ g (f x) âˆ‚Î¼ :=
integral_image_eq_integral_abs_det_fderiv_smul Î¼ hs hf h_inj g
-- QUOTE.
